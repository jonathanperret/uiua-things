# Experimental!

JsonParse â† &i "json.ua" "JsonParse"

ExpandSlice â† +âŠ™â‡¡ Â°âŠŸ

Log â† &p

# map -- keys
MapKeys â† â–½ â‰¡(Â¬â‰NaN Â°â–¡). Â°â–¡âŠ¢

# map -- pairs
MapPairs â† â‰âŠŸÂ°map

EmptyStack â† {}

# runtime = { callstack stack tempstacks }

MakeRuntime â† {âŠ™âŠ™âˆ˜}

RtCallStack â† Â°â–¡âŠ¡0
RtStack â† Â°â–¡âŠ¡1
RtTempStacks â† Â°â–¡âŠ¡2

# slice -- frame
MakeFrame â† (|1
  ExpandSlice
  0 # pc
  {âŠ™âˆ˜}
)

# fn on stack = [ sig slice ]

Trace â† âŠƒâˆ˜(&p$"â”Œâ•´â¸®\n_\nâ””â•´â•´â•´â•´"$"â”œâ•´_")

Stack â† âŠƒâˆ˜(&p$"â”Œâ•´?\n_\nâ””â•´â•´â•´â•´"/âŠ$"_\n_"â‰¡(â–¡$"â”œâ•´_"Â°â–¡)â‡Œ)

Args â† â†˜1 &args

NoadicNoOutputNames â† {"stack"}
NoadicNoOutputFns â† (Stack|â¤"bad prim id"0)

NoadicOneOutputNames â† {"tag" "now" "eta" "pi" "tau" "infinity" "scan_line" "rand" "args"}
NoadicOneOutputFns â† (tag|now|Î·|Ï€|Ï„|âˆ|&sc|âš‚|Args)

MonadicNoOutputNames â† {"pop" "show" "prin" "print" "change_directory" "im_show"}
MonadicNoOutputFns â† (;|&s|&pf|&p|&cd|&ims)

MonadicOneOutputNames â† {
  "identity" "trace"
  "not" "sign" "neg" "abs" "sqrt" "sin" "floor" "ceil" "round"
  "len" "shape" "range" "first" "reverse" "deshape" "fix" "bits" "transpose" "rise" "fall"
  "where" "classify" "deduplicate" "box" "unbox" "parse"
  "utf" "type" "f_read_all_bytes" "f_read_all_str"}
MonadicOneOutputFns â† (
  âˆ˜
| Trace
| Â¬
| Â±
| Â¯
| âŒµ
| âˆš
| â—‹
| âŒŠ
| âŒˆ
| â…
| â§»
| â–³
| â‡¡
| âŠ¢
| â‡Œ
| â™­
| Â¤
| â‹¯
| â‰
| â
| â–
| âŠš
| âŠ›
| âŠ
| â–¡
| Â°â–¡
| â‹•
| utf
| type
| &frab
| &fras
)

MonadicTwoOutputNames â† {"dup" "gen"}
MonadicTwoOutputFns â† (.|gen)

DyadicNoOutputNames â† {"assert" "f_write_all"}
DyadicNoOutputFns â† (â¤|&fwa)

DyadicOneOutputNames â† {
  "eq" "ne" "lt" "le" "gt" "ge" "add" "sub" "mul" "div" "mod" "pow" "log" "min" "max" "atan" "complex"
  "match" "couple" "join" "select" "pick" "reshape" "rerank" "take" "drop" "rotate" "windows" "keep" "find" "member" "index_of"
  "deal" "map" "has" "get" "remove" "regex"}
DyadicOneOutputFns â† (
  =
| â‰ 
| <
| â‰¤
| >
| â‰¥
| +
| -
| Ã—
| Ã·
| â—¿
| â¿
| â‚™
| â†§
| â†¥
| âˆ 
| â„‚
| â‰
| âŠŸ
| âŠ‚
| âŠ
| âŠ¡
| â†¯
| â˜‡
| â†™
| â†˜
| â†»
| â—«
| â–½
| âŒ•
| âˆŠ
| âŠ—
| deal
| map
| has
| get
| remove
| regex
)

DyadicTwoOutputNames â† {"flip"}
DyadicTwoOutputFns â† (:|â¤"bad prim id"0)

DyadicThreeOutputNames â† {"over"}
DyadicThreeOutputFns â† (,|â¤"bad prim id"0 ,)

TriadicNoOutputNames â† {"insert"}
TriadicOneOutputFns â† (insert|â¤"bad prim id"0 â‹…â‹…âˆ˜)

PrimNameLists â† {
  NoadicNoOutputNames
  NoadicOneOutputNames
  MonadicNoOutputNames
  MonadicOneOutputNames
  MonadicTwoOutputNames
  DyadicNoOutputNames
  DyadicOneOutputNames
  DyadicTwoOutputNames
  DyadicThreeOutputNames
  TriadicNoOutputNames}

PrimIds â† â‰¡(â–¡â‰¡âŠ‚âŠ™Â°â–¡) âŠƒ(â‡¡â§»|â‰¡(â–¡â‡¡â§»)) PrimNameLists

PrimNamesToIds â† map âˆ©âŠ/âŠ‚ PrimNameLists PrimIds

# primid stack -- stack'
ExecPrimitive â† (
  Â°âŠŸ
  (
    NoadicNoOutputFns
  | âŠ‚â–¡ NoadicOneOutputFns
  | MonadicNoOutputFns âŠ™âŠƒ(Â°â–¡âŠ¢|â†˜1)
  | âŠ‚â–¡ MonadicOneOutputFns âŠ™âŠƒ(Â°â–¡âŠ¢)(â†˜1)
  | âŠ‚{âŠ™âˆ˜} MonadicTwoOutputFns âŠ™âŠƒ(Â°â–¡âŠ¢)(â†˜1)
  | DyadicNoOutputFns âŠ™âŠƒ(Â°{âŠ™âˆ˜}â†™2|â†˜2)
  | âŠ‚â–¡ DyadicOneOutputFns âŠ™âŠƒ(Â°{âŠ™âˆ˜}â†™2|â†˜2)
  | âŠ‚{âŠ™âˆ˜} DyadicTwoOutputFns âŠ™âŠƒ(Â°{âŠ™âˆ˜}â†™2|â†˜2)
  | âŠ‚{âŠ™âŠ™âˆ˜} DyadicThreeOutputFns âŠ™âŠƒ(Â°{âŠ™âˆ˜}â†™2|â†˜2)
  | âŠ‚â–¡ TriadicOneOutputFns âŠ™âŠƒ(Â°{âŠ™âŠ™âˆ˜}â†™3|â†˜3)
  )
)

NotImplemented â† |2 âˆ˜ â¤âŠ™0 $"_ is not implemented"

# {ident} runtime -- runtime'
Comment â† NotImplemented "Comment"

# {index call sig} runtime -- runtime'
CallGlobal â† NotImplemented "CallGlobal"

# {span index} runtime -- runtime'
BindGlobal â† NotImplemented "BindGlobal"

# { } runtime -- runtime'
BeginArray â† NotImplemented "BeginArray"

# {boxed span} runtime -- runtime'
EndArray â† NotImplemented "EndArray"

# {index} runtime -- runtime'
Call â† NotImplemented "Call"

# [ sig slice ] runtime -- runtime'
PushFunc â† (
  :
  âœRtStack(
    :
    âŠ‚â–¡ # push fn

  )
)

# {fncount sig} runtime -- runtime'
Switch â† (|2
  :
  âœRtStack (
    :
    Â°{âŠ™âˆ˜} # get fncount, sig
    # -- fncount sig stack
    âŠƒ(
      Â°â–¡âŠ¡ âŠ™â‹…âˆ˜ # selector: after fns

    | â‡Œâ†™ âŠ™â‹…âˆ˜ # fns, reversed

    | â‹…âˆ˜ # keep sig

    | â†˜ +1 âŠ™â‹…âˆ˜ # drop fns and selector from stack

    )
    # -- selector fns sig stack'
    Â°â–¡âŠ¡ # pick selected fn # TODO: array selectors
    # -- fn sig stack
    Â°âŠŸ # extract fnsig and fnslice

    # -- fnsig fnslice sig stack
    âŠƒ(
      âŠ™; # drop fnslice
      # compute args to discard
      âŠƒ(â‹…âŠ¢|â‹…â‹…âˆ˜|/-â‡Œ -) # sig.args stack ((sig.args - f.sig.args) - (sig.outputs - f.sig.outputs))
      âœâ†™(â†˜ Â¯:)        # discard extra args

    | â‹…âˆ˜ # keep fnslice

    )
    # -- stack fnslice

  )
  # -- runtime fnslice
  âœRtCallStack(âŠ‚ MakeFrame :) # push new frame onto callstack

)

# parts runtime -- runtime'
Format â† (|2
  :
  âœRtStack (
    :
    # -- parts stack
    âŠƒ(âˆ˜|â‰¡âœÂ°â–¡$"_" âŠƒâ†™â†˜ -1â§») # take (parts-1) values from stack, stringify them
    â™­â‰â¬š(â–¡"")âŠŸ             # alternate fragments and values
    âŠ/âŠ‚                   # join everything up
    âŠ‚â–¡                    # push resulting string

  )
)

# {func} runtime -- runtime'
Dynamic â† NotImplemented "Dynamic"

# {count span} runtime -- runtime'
PushLocals â† NotImplemented "PushLocals"

# {} runtime -- runtime'
PopLocals â† NotImplemented "PopLocals"

# {index span} runtime -- runtime'
GetLocal â† NotImplemented "GetLocal"

# {count span unbox} runtime -- runtime'
Unpack â† NotImplemented "Unpack"

# {count} runtime -- runtime'
PushTempFunctions â† NotImplemented "PushTempFunctions"

# {count} runtime -- runtime'
PopTempFunctions â† NotImplemented "PopTempFunctions"

# {offset sig span} runtime -- runtime'
GetTempFunction â† NotImplemented "GetTempFunction"

# count runtime -- runtime'
TouchStack â† (|2
  â‹…âˆ˜ # TODO update arraystack

)

# [stackid count] runtime -- runtime'
PushTemp â† (|2
  Â°âŠŸ
  # -- stackid count runtime
  âŠƒ(â‹…â‹…âˆ˜|â‹…âˆ˜|âˆ˜)
  # -- runtime count stackid
  # take from stack
  âœRtStack (âŠƒâ†˜â†™ :)
  # -- runtime' values stackid
  âŠƒ(âˆ˜|â‹…â‹…âˆ˜|â‹…âˆ˜)
  # -- runtime stackid values
  âœ(RtTempStacks) (
    # -- tempstacks stackid values
    :
    âœ(Â°â–¡âŠ¡) (
      âŠ‚â‡Œ:
    )
  )
)

# [stackid count] runtime -- runtime'
PopTemp â† (|2
  Â°âŠŸ
  # -- stackid count runtime
  âŠƒ(â‹…â‹…âˆ˜|âˆ˜|â‹…âˆ˜)
  # -- runtime stackid count
  âœ(RtTempStacks) (
    # -- tempstacks stackid count
    :
    âœ(Â°â–¡âŠ¡) (
      âŠƒâ†˜â†™ :
    )
  )
  # -- runtime values
  # push to stack
  âœRtStack (âŠ‚â‡Œ:)
)

# {stack count span} runtime -- runtime'
CopyToTemp â† NotImplemented "CopyToTemp"

# {stack offset count span} runtime -- runtime'
CopyFromTemp â† NotImplemented "CopyFromTemp"

# {stack count span} runtime -- runtime'
DropTemp â† NotImplemented "DropTemp"

# {sig} runtime -- runtime'
PushSig â† NotImplemented "PushSig"

# {} runtime -- runtime'
PopSig â† NotImplemented "PopSig"

# {i n} runtime -- runtime'
SetOutputComment â† NotImplemented "SetOutputComment"

InstrTypePush â† 0
InstrTypePrim â† 1
InstrTypeOther â† 2

InstrNames â† {
  "Comment"
  "CallGlobal"
  "BindGlobal"
  "BeginArray"
  "EndArray"
  "Call"
  "PushFunc"
  "Switch"
  "Format"
  "Dynamic"
  "PushLocals"
  "PopLocals"
  "GetLocal"
  "Unpack"
  "PushTempFunctions"
  "PopTempFunctions"
  "GetTempFunction"
  "TouchStack"
  "PushTemp"
  "PopTemp"
  "CopyToTemp"
  "CopyFromTemp"
  "DropTemp"
  "PushSig"
  "PopSig"
  "SetOutputComment"}

InstrFns â† (
  Comment
| CallGlobal
| BindGlobal
| BeginArray
| EndArray
| Call
| PushFunc
| Switch
| Format
| Dynamic
| PushLocals
| PopLocals
| GetLocal
| Unpack
| PushTempFunctions
| PopTempFunctions
| GetTempFunction
| TouchStack
| PushTemp
| PopTemp
| CopyToTemp
| CopyFromTemp
| DropTemp
| PushSig
| PopSig
| SetOutputComment
)

InstrNamesToIds â† map âŠƒ(âˆ˜|â‡¡â§») InstrNames

# instr = { (push|prim|other) (value|primid|{ instrid args }) }

# jsoninstr -- instr
AnalyzeInstr â† (
  type.
  (
    {InstrTypePush âˆ˜} # number literal

  | [] â¤$"complex in JSON? _"âŠ™0
  | {InstrTypePush âˆ˜} # string literal

  | typeÂ°â–¡âŠ¢.
    (
      |1       # array literal: [ type shape elements ]
      : Â°{âŠ™âŠ™âˆ˜} # -- shape type elements
      âŠ“(
        âŠâ‰¡âˆ˜ # unbox shape

        | # unbox elements
        (
          # number array
          â‰¡Â°â–¡
            | # complex array
          â‰¡(â„‚Â°{:}Â°â–¡)
            | # char array
          â‰¡Â°â–¡
            | # box array
          âˆ˜
        )
      )
      # -- shape elements
      Â±â§».
      (
        # scalar (used for char literals)
        âŠ¢âŠ¢ ;
        | # regular array: apply shape
        â†¯
      )
      {InstrTypePush âˆ˜}
    | [] â¤$"complex in JSON? _"âŠ™0
    | #  [ "prim", â€¦ ]
      {InstrTypePrim âˆ˜} get: PrimNamesToIds âŠ¢
    | # { "Instr": [ argsâ€¦ ] }
      Â°[{âŠ™âˆ˜}] MapPairs
      get: InstrNamesToIds
      âŠƒ(âŠ™âˆ˜|âˆ˜)
      (
        âˆ˜ # Comment

        | âˆ˜ # CallGlobal

        | âˆ˜ # BindGlobal

        | âˆ˜ # BeginArray

        | âˆ˜ # EndArray

        | âˆ˜ # Call

        | [âŠ“(;|âŠâ‰¡âˆ˜|âŠâ‰¡âˆ˜)] Â°{âŠ™âŠ™âˆ˜} # PushFunc(id, slice, sig)

        | {âŠ“(âˆ˜|âŠâ‰¡âˆ˜|;)} Â°{âŠ™âŠ™âˆ˜} # Switch

        | Â°â–¡âŠ¢ # Format

        | âˆ˜ # Dynamic

        | âˆ˜ # PushLocals

        | âˆ˜ # PopLocals

        | âˆ˜ # GetLocal

        | âˆ˜ # Unpack

        | âˆ˜ # PushTempFunctions

        | âˆ˜ # PopTempFunctions

        | âˆ˜ # GetTempFunction

        | Â°â–¡âŠ¢ # TouchStack

        | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # PushTemp(stack, count, span)

        | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # PopTemp(stack, count, span)

        | âˆ˜ # CopyToTemp

        | âˆ˜ # CopyFromTemp

        | âˆ˜ # DropTemp

        | âˆ˜ # PushSig

        | âˆ˜ # PopSig

        | âˆ˜ # SetOutputComment

      )
      :
      {InstrTypeOther {âŠ™âˆ˜}}
    )
  )
)

# runtime instr -- runtime'
ExecInstr â† (|2
  :
  # -- instr runtime
  Â°{âŠ™âˆ˜} # -- instrtype instrdetail runtime
  (
    # push
    # -- value runtime
    :
    # -- runtime value
    âœRtStack(
      :
      âŠ‚â–¡ # push onto stack

    )
  | # prim
    # -- primid runtime
    :
    # -- runtime primid
    âœRtStack(
      :
      ExecPrimitive
    )
  | # other
    # -- jsoninstr runtime
    Â°{âŠ™âˆ˜} # -- jsoninstrid jsoninstr runtime
    InstrFns
  )
)

# frame = { pc addrs }
FramePc â† âŠ¢

# frame -- bool
FrameDone â† â‰¤ âŠ™â§» Â°{âŠ™âˆ˜}

# frame instrs -- instr
FrameGetInstr â† Â°â–¡âŠ¡âŠ¡ Â°{âŠ™âˆ˜}

# runtime instrs -- runtime'
Advance â† (|2
  # -- runtime instrs
  âŠƒ(FrameDone âŠ¢RtCallStack|âˆ˜)
  # reached end of top frame?
  (
    |2 # no, go on
    # -- runtime instrs
    âœ(âŠ¢RtCallStack)(|2.2
      # -- topframe instrs
      âŠƒ(
        âœFramePc (+1) # bump pc

        | FrameGetInstr # fetch next instr

      )
    )
    # -- runtime' instr
    ExecInstr
    # -- runtime

  | |1 # yes: destroy it, keep stack
    # -- runtime
    âœRtCallStack (â†˜1)
  )
)

# callstack -- bool
CallStackActive â† (
  (Â¬FrameDone Â°[âˆ˜]|1) >1â§».
)

# jsonasm -- finalstack
Run â† (|1
  âŠƒ(
    âŠâ‰¡â‰¡âˆ˜Â°â–¡get "top_slices"
    â‰¡MakeFrame # initial callstack from top_slices

  | Â°â–¡get "instrs"
    â‰¡(AnalyzeInstr Â°â–¡)
  )
  # -- callstack instrs
  âŠ™EmptyStack # stack
  # -- callstack stack instrs
  âŠ™âŠ™{âŠ‚ {"Inline"} EmptyStack âŠ‚ {"Under"} EmptyStack}
  # -- callstack stack tempstacks instrs
  MakeRuntime # -- runtime instrs
  â¢(
    |2.2 Advance âŠ™. # keep instrs

  | CallStackActive Â°â–¡âŠ¢
  )
  # -- runtime instrs
  âŠ™;      # drop instrs
  RtStack # extract stack

)

GetProgramPath â† â£(Â°â–¡âŠ¢&args|â‹…"")
EndsWith â† â‰ âŠƒâˆ˜(â†™Â¯â§»)
IsImported â† Â¬EndsWith "vm.ua" GetProgramPath

StackColors â† +200Ã—55â‹¯5_4_6_2_3_1

DumpColoredStack â† (
  â‰¡(&pf "\x1b[m" &sÂ°â–¡ &pf $"\x1b[38;2;_;_;_m" Â°[âŠ™âŠ™âˆ˜]) â†¯: StackColors âŠ‚:3 â§». â‡Œ
)

Main â† (
  &fras Â°â–¡ âŠ¡1 &args
  JsonParse
  Run
  DumpColoredStack
)

# *** Tests support ***

MkTemp â† (â¤âŠƒ(:Â¬âŠ™â‹…âˆ˜|â–½â‰ @\n.;) &runc "mktemp") # keep the parentheses!

# contents -- â€¦
WithTempFile â† setund(
  âŠƒâˆ˜ &fwa MkTemp
| MkTemp
  âŠƒ&fwa .
| &fde
)

CompileAndRun â† (
  âŠ‚"# Experimental!\n"
  âœWithTempFile (â‹…âŠ™; &runc {"uiua" "build" "-o" "/dev/stdout" âˆ˜})
  JsonParse
  Run
)
Aeq â† â¤âŠƒ($"\nexpected\n_\ngot\n_")â‰
Check â† Aeq âŠ™CompileAndRun

---
Replace â† âŠ/âŠ‚ â†˜1 â™­â‰¡âŠ‚ {âˆ˜}: âŠ¢â‡Œâ‰ regex âŠƒ(âŠ‚"(.*?)"|âŠ‚: âŠ™â‹…âˆ˜|â‹…âˆ˜)
â¤âŠƒâ‹…âˆ˜â‰ "azzbzz" Replace "cc" "zz" "accbcc"

Escape â† â†˜Â¯1 âŠ/âŠ‚ â†˜1â™­â‰¡âŠ‚ âŠƒ(â–¡âŠ‚@\\|âŠ•â–¡âœâ–½Â¯:\+.=, âŠ™(âŠ‚:@.))
â¤âŠƒâ‹…âˆ˜â‰ "a\\b\\\"c" Escape @" "a\\b\"c"
â¤âŠƒâ‹…âˆ˜â‰ "a\\\\b\"c" Escape @\\ "a\\b\"c"

MakeCheckProgram â† (
  âŠƒ(
    â¤"must run with absolute path for tests"=@/âŠ¢. GetProgramPath
  | âŠœâ–¡â‰ @\t.
    âŠƒ(
      (""|âŠ/$"_\n_") Â±â§». â†˜Â¯1
    | Â°â–¡âŠ¢â‡Œ
    )
  | $"\"_\"" Replace @\t "\\n" Escape @" Escape @\\ Escape @\\
  )
  $ # Experimental!
  $ Check â† &i "_" "Check"
  $ _
  $ {
  $ _
  $ }
  $ Check: _

)

# expr -- success
AutoCheck â† (|1
  MakeCheckProgram.
  # programtext expr
  âœWithTempFile (&runc {"uiua" "run" "--no-format" âˆ˜})
  # -- exitcode stdout stderr
  âŠƒ(
    â†§ âˆ©(=0) âŠ™â‹…â§» # success is exitcode=0 && empty stderr

  | â‹…âŠ‚ # join stderr to stdout

  )
  # -- success output expr
  (
    &p$"âŒ _\n_":
    0
  | # &pâ‹…$"âœ… _"
    1
  )
)

ThreadCount â† NumProcs

Parallel! â† (
  âŠ/âŠ‚ â–½â‰¡â§». â‰¡(â–¡â‰¡wait â‰¡spawn^1 â–½â‰¡(Â¬â‰â–¡0).) â¬š(â–¡0)â†¯ âŠŸ :ThreadCount Â¯1
)

RunTests â† &pâœnow(
  {
    $ 123
    $ "hello"
    $ @x
    $ @ğŸ˜‡
    $ []
    $ [i 0 1 2]
    $ {}
    $ [[4 5 6][7 8 9]]
    $ ["x" "y"]
    $ {"x" "yz"}

    $ .2
    $ ,1 2
    $ :1 2
    $ ;1 2 3

    $ âˆ˜3
    $ Â¬ 3
    $ Â± 3
    $ Â¯ 1
    $ âŒµ `1
    $ âˆš 4
    $ â—‹ 0
    $ âŒŠ 1234.56
    $ âŒˆ 1.234
    $ â… 5.678

    $ =1 2
    $ â‰ 1 2
    $ <1 2
    $ â‰¤1 2
    $ >1 2
    $ â‰¥1 2
    $ +2 4
    $ -2 5
    $ *2 4
    $ Ã·2 6
    $ â—¿2 7
    $ â¿2 3
    $ â‚™2 8
    $ â†§3 8
    $ â†¥3 8
    $ âˆ 1 0
    $ â„‚1 2

    $ â§»5
    $ â–³5
    $ â‡¡5
    $ âŠ¢[1 2 3]
    $ â‡Œ[1 2 3]
    $ â™­5
    $ Â¤5
    $ â‹¯27
    $ â‰.[[1 2] [3 4] [5 6]]
    $ â[6 2 7 0 Â¯1 5]
    $ â–[6 2 7 0 Â¯1 5]
    $ âŠš [1 0 0 1 0 1 1 0]
    $ âŠ›[7 7 8 0 1 2 0]
    $ âŠ[7 7 8 0 1 2 0]
    $ âŠ”â–¡5
    $ â‹• "17"

    $ â‰ [0 1 2] [0 1 2]
    $ âŠŸ 1 2
    $ âŠ‚ 1 2
    $ âŠ 2 [8 3 9 2 0]
    $ âŠ¡ 2 [8 3 9 2 0]
    $ â†¯ [2 3] [1 2 3 4 5 6]
    $ â˜‡ 0 â†¯[2 3 3]â‡¡18
    $ â†™ 3 [8 3 9 2 0]
    $ â†˜ 3 [8 3 9 2 0]
    $ â†»1 â‡¡5
    $ â—«2 .â‡¡4
    $ â–½ [1 0 2 3 1] [8 3 9 2 0]
    $ âŒ• 5 [1 8 5 2 3 5 4 5 6 7]
    $ âˆŠ 2 [1 2 3]
    $ âŠ— 2 [1 2 3]

    $ â¤"ok" 1
    $ gen0
    $ deal0 [1 2 3 4 5]
    $ regex "h([io])" "hihaho"
    $ utf "hello!"
    $ â‰¥0 tag
    $ type 5
    $ Â±now

    $ Î·
    $ Ï€
    $ Ï„
    $ âˆ

    $ map 1\_2 3\_4
    $ insert 1 2 {}
    $ has 1 map 1\_2 3\_4
    $ get 1 1\_2 3\_4
    $ remove 3 map 1\_2 3\_4

    $ - . âš‚

    $ &sc
    $ &cd "/tmp"
    $ &fras "/tmp/data1.tmp" &fwa "/tmp/data1.tmp" "data"
    $ &frab "/tmp/data2.tmp" &fwa "/tmp/data2.tmp" "data"
    $ &ims [[1 0][0 1]]
    $ type &args

    $ (10|20)0
    $ (10 20|20 30)1
    $ (*2|*4+)1 10 90
    $ (*2|*4+)0 10 90
    $ (*2|*4+)0 10 90 99
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)0 10 20 30 40
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)1 10 20 30 40

    $ F â† +123\tF 4

    $ $"\_" 100
    $ $"[x=\_ y=\_]" 100 200

    $ âŠ™100 200
    $ âŠ™âŠ™âˆ˜ 100 200 300
    $ âŠ™â‹…â‹…âŠ™100 200 300 400 500
    $ âŠ™â‹…â‹…âŠ™âˆ˜ 100 200 300 400 500

    $ âœ(Ã—10) â… 1.234
  }

  âŠ/âŠ‚ â‰¡(âœÂ°â–¡(âŠœâ–¡ â‰ @\n.))
  Parallel!(AutoCheck Â°â–¡)
  &pâŠ¡:"ğŸ˜­ğŸ‰" /â†§
)
Â¬IsImported
(
  # imported: do nothing

| # running
  =1â§»&args
  (
    # do nothing

  | RunTests
  )
)
---

Â¬IsImported
(
  # imported: do nothing

| # running
  >1â§»&args
  (
    # do nothing

  | Main
  )
)
