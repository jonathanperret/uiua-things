# Experimental!

JsonParse â† &i "json.ua" "JsonParse"

ExpandSlice â† +âŠ™â‡¡ Â°âŠŸ

Log â† &p

Noadic! â† (
  ^0
  âŠ‚â–¡
)

Monadic! â† (
  âŠƒâŠ¢(â†˜1)
  Â°â–¡
  ^1
  âŠ‚â–¡
)

MonadicNoOutput! â† (
  âŠƒâŠ¢(â†˜1)
  Â°â–¡
  ^1.0
)

MonadicTwoOutput! â† (
  âŠƒâŠ¢(â†˜1)
  Â°â–¡
  ^1.2
  âŠ‚{âŠ™âˆ˜}
)

Dyadic! â† (
  âŠƒâ†™â†˜ 2
  Â°{âŠ™âˆ˜}
  ^2
  âŠ‚â–¡
)

DyadicNoOutput! â† (
  âŠƒâ†™â†˜ 2
  Â°{âŠ™âˆ˜}
  ^2.0
)

Triadic! â† (
  âŠƒâ†™â†˜ 3
  Â°{âŠ™âŠ™âˆ˜}
  ^3
  âŠ‚â–¡
)

# map -- keys
MapKeys â† â–½ â‰¡(Â¬â‰NaN Â°â–¡). Â°â–¡âŠ¢

# map -- pairs
MapPairs â† â‰âŠŸ âˆ©â–½ ,: â‰¡(Â¬â‰NaN Â°â–¡). Â°{âŠ™âˆ˜}

EmptyStack â† {}

# slice stack -- frame
MakeFrame â† (|2
  ExpandSlice
  0 # pc
  {âŠ™âŠ™âˆ˜}
)

# { Switch { count, sig, span } } stack -- stack' newframe?
Switch â† (
  âŠ™(âŠâ‰¡âˆ˜) Â°{âŠ™âˆ˜}â†™2 ;Â°{âŠ™âˆ˜} # get fncount, sig
  # -- fncount sig stack
  âŠƒ(
    â†˜ +âŠ™âŠ¢ +1     # remaining stack
  | Â°â–¡âŠ¡ âŠ™â‹…âˆ˜      # selector: after fns
  | â‡Œâ†™ âŠ™â‹…âˆ˜       # fns, reversed
  | â‹…âˆ˜           # keep sig
  | â†˜âŠƒâˆ˜(â†™ +âŠ™âŠ¢)+1 # inputs: after fns and selector
  )
  # -- stack' selector fns sig newstack
  âŠ™(
    Â°â–¡âŠ¡ # pick selected fn # TODO: array selectors
    # -- fn sig newstack
    Â°âŠŸ # extract fnsig and fnslice
    # -- fnsig slice sig newstack
    # compute args to discard
    âŠƒ(
      â‹…âˆ˜         # keep slice
    | /-â‡Œ - âŠ™â‹…âŠ™âˆ˜ # (sig.args - f.sig.args) - (sig.outputs - f.sig.outputs)
      # -- discardcount newstack
      â†˜ Â¯ # discard extra args
    )
    # -- slice newstack
    [MakeFrame]
  )
  # -- stack [newframe]
)

# fn on stack = [ sig slice ]

# { PushFunc { id, sig, slice } } stack -- stack' newframe?
PushFunc â† (
  ;Â°{âŠ™âŠ™âˆ˜} ;Â°{âŠ™âˆ˜} # get slice and sig
  âˆ©âŠâ‰¡âˆ˜           # clean them up
  âŠŸ              # couple them
  âŠ‚â–¡             # push fn
  âŠ™[]            # no new frame
)

# instr stack -- stack' newframe?
ExecuteInstruction â† (|2.2
  type.
  (
    âŠ™[] âŠ‚â–¡ # number literal
  | âŠ™[] â¤$"complex in JSON? _"âŠ™0
  | âŠ™[] âŠ‚â–¡ # string literal
  | typeÂ°â–¡âŠ¢.
    (
      # array literal: [ type shape elements ]
      âŠ™(âŠâ‰¡âˆ˜) Â°{âŠ™âŠ™âˆ˜}
      (
        # number array
        âŠ™â‰¡Â°â–¡
        | # complex array
        âŠ™â‰¡(â„‚Â°{:}Â°â–¡)
        | # char array
        âŠ™â‰¡Â°â–¡
        | # box array
        âŠ™âˆ˜
      )
      # -- shape elements
      Â±â§».
      (
        # scalar (used for char literals)
        âŠ‚â–¡ âŠ¢âŠ¢ ;
        | # regular array: apply shape
        âŠ‚â–¡ â†¯
      )
      âŠ™[]
    | âŠ™[] â¤$"complex in JSON? _"âŠ™0
    | âŠ—: {"dup" "pop" "over" "flip" "identity"
          "not" "sign" "neg" "abs" "sqrt" "sin" "floor" "ceil" "round"
          "eq" "ne" "lt" "le" "gt" "ge" "add" "sub" "mul" "div" "mod" "pow" "log" "min" "max" "atan" "complex"
          "len" "shape" "range" "first" "reverse" "deshape" "fix" "bits" "transpose" "rise" "fall" "where" "classify" "deduplicate" "box" "unbox" "parse"
          "match" "couple" "join" "select" "pick" "reshape" "rerank" "take" "drop" "rotate" "windows" "keep" "find" "member" "index_of"
          "assert"
          "gen"
          "deal" "regex" "utf" "tag" "type" "now"
          "eta" "pi" "tau" "infinity"
          "map" "insert" "has" "get" "remove" "stack" "trace"
          "show" "prin" "print" "scan_line"
          "rand"
          "change_directory" "f_read_all_bytes" "f_read_all_str" "f_write_all"
          "args"
          "im_show"} âŠ¢.
      (
        â‹…(âŠ‚âŠ¢.)    # dup
        | â‹…(â†˜1)   # pop
        | â‹…(âŠ‚âŠ¡1.) # over
        | â‹…âœ(â†™2)â‡Œ # flip
        | â‹…(â†˜0)   # identity
        | â‹…Monadic!Â¬
        | â‹…Monadic!Â±
        | â‹…Monadic!Â¯
        | â‹…Monadic!âŒµ
        | â‹…Monadic!âˆš
        | â‹…Monadic!â—‹
        | â‹…Monadic!âŒŠ
        | â‹…Monadic!âŒˆ
        | â‹…Monadic!â…
        | â‹…Dyadic!=
        | â‹…Dyadic!â‰ 
        | â‹…Dyadic!<
        | â‹…Dyadic!â‰¤
        | â‹…Dyadic!>
        | â‹…Dyadic!â‰¥
        | â‹…Dyadic!+
        | â‹…Dyadic!-
        | â‹…Dyadic!Ã—
        | â‹…Dyadic!Ã·
        | â‹…Dyadic!â—¿
        | â‹…Dyadic!â¿
        | â‹…Dyadic!â‚™
        | â‹…Dyadic!â†§
        | â‹…Dyadic!â†¥
        | â‹…Dyadic!âˆ 
        | â‹…Dyadic!â„‚
        | â‹…Monadic!â§»
        | â‹…Monadic!â–³
        | â‹…Monadic!â‡¡
        | â‹…Monadic!âŠ¢
        | â‹…Monadic!â‡Œ
        | â‹…Monadic!â™­
        | â‹…Monadic!Â¤
        | â‹…Monadic!â‹¯
        | â‹…Monadic!â‰
        | â‹…Monadic!â
        | â‹…Monadic!â–
        | â‹…Monadic!âŠš
        | â‹…Monadic!âŠ›
        | â‹…Monadic!âŠ
        | â‹…Monadic!â–¡
        | â‹…Monadic!Â°â–¡
        | â‹…Monadic!â‹•
        | â‹…Dyadic!â‰
        | â‹…Dyadic!âŠŸ
        | â‹…Dyadic!âŠ‚
        | â‹…Dyadic!âŠ
        | â‹…Dyadic!âŠ¡
        | â‹…Dyadic!â†¯
        | â‹…Dyadic!â˜‡
        | â‹…Dyadic!â†™
        | â‹…Dyadic!â†˜
        | â‹…Dyadic!â†»
        | â‹…Dyadic!â—«
        | â‹…Dyadic!â–½
        | â‹…Dyadic!âŒ•
        | â‹…Dyadic!âˆŠ
        | â‹…Dyadic!âŠ—
        | â‹…DyadicNoOutput!â¤
        | â‹…MonadicTwoOutput!gen
        | â‹…Dyadic!deal
        | â‹…Dyadic!regex
        | â‹…Monadic!utf
        | â‹…Noadic!tag
        | â‹…Monadic!type
        | â‹…Noadic!now
        | â‹…Noadic!Î·
        | â‹…Noadic!Ï€
        | â‹…Noadic!Ï„
        | â‹…Noadic!âˆ
        | â‹…Dyadic!map
        | â‹…Triadic!insert
        | â‹…Dyadic!has
        | â‹…Dyadic!get
        | â‹…Dyadic!remove
        | â‹…(&p$"â”Œâ•´?\n_\nâ””â•´â•´â•´â•´"/âŠ$"_\n_"â‰¡(â–¡$"â”œâ•´_"Â°â–¡)â‡Œ.) # stack
        | â‹…(&p$"â”Œâ•´â¸®\n_\nâ””â•´â•´â•´â•´"$"â”œâ•´_"Â°â–¡âŠ¢.)              # trace
        | â‹…MonadicNoOutput!&s
        | â‹…MonadicNoOutput!&pf
        | â‹…MonadicNoOutput!&p
        | â‹…Noadic!&sc
        | â‹…Noadic!âš‚
        | â‹…MonadicNoOutput!&cd
        | â‹…Monadic!&frab
        | â‹…Monadic!&fras
        | â‹…DyadicNoOutput!&fwa
        | â‹…Noadic!(â†˜1 &args)
        | â‹…MonadicNoOutput!&ims
        | â¤$"unknown instr: _"âŠ™0
      )
      âŠ™[] # no new frame
    |     # { "Instr": [ argsâ€¦ ] }
      âŠ¢ MapPairs
      âŠ—: {"PushFunc" "Switch"} âŠ¢.
      (
        PushFunc
        | Switch
        | âŠ™[] â¤$"unknown instr: _"âŠ™0
      )
    )
  )
)

# frame = { pc addrs stack }

# frame -- bool
FrameDone â† â‰¤ âŠ™â§» Â°{âŠ™âˆ˜}â†™2

# callstack instrs -- callstack'
Advance â† (|2
  FrameDone âŠ¢ . # reached end of top frame?
  (
    # no, proceed
    âœâŠ¢(
      âœ(Â°{âŠ™âŠ™âˆ˜}) (
        # -- pc addrs stack instrs
        âŠƒ(
          +1     # advance pc
            | â‹…âˆ˜ # keep addrs
            |    # -- pc addrs stack instrs

          âŠƒ(Â°â–¡âŠ¡âŠ¡ âŠ™âŠ™â‹…âˆ˜|â‹…â‹…âˆ˜) # fetch next instr, keep stack

          # -- instr stack
          ExecuteInstruction
          # -- stack' newframe?
        )
        # -- pc addrs stack newframe?
      )
      # -- frame newframe?
      âŠ‚: # push new frame (if it exists) on top of callstack
    )
  | # yes: pop it and merge its stack with previous frame
    âŠƒ(â†˜1|Â°â–¡âŠ¡0_2)
    âœ(Â°â–¡âŠ¡0_2)âŠ‚
  )
)

CallStackActive â† (
  (Â¬FrameDone Â°[âˆ˜]|1)>1â§».
)

# jsonasm -- finalstack
Run â† (|1
  âŠƒ(
    âŠâ‰¡â‰¡âˆ˜Â°â–¡get "top_slices"
    â‰¡(MakeFrame : EmptyStack) # initial callstack from top_slices
  | Â°â–¡get "instrs"
  )
  # -- callstack instrs
  â¢(
    âŠƒAdvance(â‹…âˆ˜)
  | CallStackActive
  )
  âŠ™;            # drop instrs
  â‹…â‹…âˆ˜ Â°{âŠ™âŠ™âˆ˜} âŠ¢â‡Œ # final stack from top frame
)

GetProgramPath â† â£(Â°â–¡âŠ¢&args|â‹…"")
EndsWith â† â‰ âŠƒâˆ˜(â†™Â¯â§»)
IsImported â† Â¬EndsWith "vm.ua" GetProgramPath

StackColors â† +200Ã—55â‹¯5_4_6_2_3_1

DumpColoredStack â† (
  â‰¡(&pf "\x1b[m" &sÂ°â–¡ &pf $"\x1b[38;2;_;_;_m" Â°[âŠ™âŠ™âˆ˜]) â†¯: StackColors âŠ‚:3 â§». â‡Œ
)

Main â† (
  &fras Â°â–¡ âŠ¡1 &args
  JsonParse
  Run
  DumpColoredStack
)

# *** Tests support ***

MkTemp â† (â¤âŠƒ(:Â¬âŠ™â‹…âˆ˜|â–½â‰ @\n.;) &runc "mktemp") # keep the parentheses!

# contents -- â€¦
WithTempFile â† setund(
  âŠƒâˆ˜ &fwa MkTemp
| MkTemp
  âŠƒ&fwa .
| &fde
)

CompileAndRun â† (
  âŠ‚"# Experimental!\n"
  âœWithTempFile (â‹…âŠ™; &runc {"uiua" "build" "-o" "/dev/stdout" âˆ˜})
  JsonParse
  Run
)
Aeq â† â¤âŠƒ($"\nexpected\n_\ngot\n_")â‰
Check â† Aeq âŠ™CompileAndRun

---
Escape â† â†˜Â¯1 âŠ/âŠ‚ â†˜1â™­â‰¡âŠ‚ âŠƒ(â–¡âŠ‚@\\|âŠ•â–¡âœâ–½Â¯:\+.=, âŠ™(âŠ‚:@.))
â¤âŠƒâ‹…âˆ˜â‰ "a\\b\\\"c" Escape @" "a\\b\"c"
â¤âŠƒâ‹…âˆ˜â‰ "a\\\\b\"c" Escape @\\ "a\\b\"c"

MakeCheckProgram â† (
  âŠƒ(
    â¤"must run with absolute path for tests"=@/âŠ¢. GetProgramPath
  | âŠƒ(âˆ˜|$"\"_\"" Escape @" Escape @\\) Escape @\\
  )
  $ # Experimental!
  $ Check â† &i "_" "Check"
  $ Check {_} _
)

# expr -- success
AutoCheck â† (|1
  MakeCheckProgram.
  # programtext expr
  âœWithTempFile (&runc {"uiua" "run" "--no-format" âˆ˜})
  # -- exitcode stdout stderr
  âŠƒ(
    â†§ âˆ©(=0) âŠ™â‹…â§» # success is exitcode=0 && empty stderr
  | â‹…âŠ‚          # join stderr to stdout
  )
  # -- success output expr
  (
    &p$"âŒ _\n_":
    0
  | # &pâ‹…$"âœ… _"
    1
  )
)

Parallel! â† (
  âŠ/âŠ‚ â‰¡(â–¡â‰¡wait â‰¡spawn^1 â–½â‰¡(Â¬â‰â–¡0).) â¬š(â–¡0)â†¯ âŠŸ NumProcs Â¯1
)

RunTests â† &pâœnow(
  {
    $ 123
    $ "hello"
    $ @x
    $ @ğŸ˜‡
    $ []
    $ [i 0 1 2]
    $ {}
    $ [[4 5 6][7 8 9]]
    $ ["x" "y"]
    $ {"x" "yz"}

    $ .2
    $ ,1 2
    $ :1 2
    $ ;1 2 3

    $ âˆ˜3
    $ Â¬ 3
    $ Â± 3
    $ Â¯ 1
    $ âŒµ `1
    $ âˆš 4
    $ â—‹ 0
    $ âŒŠ 1234.56
    $ âŒˆ 1.234
    $ â… 5.678

    $ =1 2
    $ â‰ 1 2
    $ <1 2
    $ â‰¤1 2
    $ >1 2
    $ â‰¥1 2
    $ +2 4
    $ -2 5
    $ *2 4
    $ Ã·2 6
    $ â—¿2 7
    $ â¿2 3
    $ â‚™2 8
    $ â†§3 8
    $ â†¥3 8
    $ âˆ 1 0
    $ â„‚1 2

    $ â§»5
    $ â–³5
    $ â‡¡5
    $ âŠ¢[1 2 3]
    $ â‡Œ[1 2 3]
    $ â™­5
    $ Â¤5
    $ â‹¯27
    $ â‰.[[1 2] [3 4] [5 6]]
    $ â[6 2 7 0 Â¯1 5]
    $ â–[6 2 7 0 Â¯1 5]
    $ âŠš [1 0 0 1 0 1 1 0]
    $ âŠ›[7 7 8 0 1 2 0]
    $ âŠ[7 7 8 0 1 2 0]
    $ âŠ”â–¡5
    $ â‹• "17"

    $ â‰ [0 1 2] [0 1 2]
    $ âŠŸ 1 2
    $ âŠ‚ 1 2
    $ âŠ 2 [8 3 9 2 0]
    $ âŠ¡ 2 [8 3 9 2 0]
    $ â†¯ [2 3] [1 2 3 4 5 6]
    $ â˜‡ 0 â†¯[2 3 3]â‡¡18
    $ â†™ 3 [8 3 9 2 0]
    $ â†˜ 3 [8 3 9 2 0]
    $ â†»1 â‡¡5
    $ â—«2 .â‡¡4
    $ â–½ [1 0 2 3 1] [8 3 9 2 0]
    $ âŒ• 5 [1 8 5 2 3 5 4 5 6 7]
    $ âˆŠ 2 [1 2 3]
    $ âŠ— 2 [1 2 3]

    $ â¤"ok" 1
    $ gen0
    $ deal0 [1 2 3 4 5]
    $ regex "h([io])" "hihaho"
    $ utf "hello!"
    $ â‰¥0 tag
    $ type 5
    $ Â±now

    $ Î·
    $ Ï€
    $ Ï„
    $ âˆ

    $ map 1\_2 3\_4
    $ insert 1 2 {}
    $ has 1 map 1\_2 3\_4
    $ get 1 1\_2 3\_4
    $ remove 3 map 1\_2 3\_4

    $ - . âš‚

    $ &sc
    $ &cd "/tmp"
    $ &fras "/tmp/data1.tmp" &fwa "/tmp/data1.tmp" "data"
    $ &frab "/tmp/data2.tmp" &fwa "/tmp/data2.tmp" "data"
    $ &ims [[1 0][0 1]]
    $ type &args

    $ (10|20)0
    $ (10 20|20 30)1
    $ (*2|*4+)1 10 20
    $ (*2|*4+)0 10 20
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)0 10 20 30 40
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)1 10 20 30 40

    ""  }

  âŠ/âŠ‚ â‰¡(âœÂ°â–¡(âŠœâ–¡ â‰ @\n.))
  Parallel!(AutoCheck Â°â–¡)
  # â‰¡(AutoCheck Â°â–¡)
  &pâŠ¡:"ğŸ˜­ğŸ‰" /â†§
)

Â¬IsImported
(
  # imported: do nothing
| # running
  =1â§»&args
  (
    # do nothing
  | RunTests
  )
)
---

Â¬IsImported
(
  # imported: do nothing
| # running
  >1â§»&args
  (
    # do nothing
  | Main
  )
)
