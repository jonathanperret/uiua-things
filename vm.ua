# Experimental!

JsonParse â† &i "json.ua" "JsonParse"

ExpandSlice â† +âŠ™â‡¡ Â°âŠŸ

Log â† &p

# map -- pairs
MapPairs â† â‰âŠŸÂ°map

EmptyStack â† {}

# runtime = { callstack stack tempstacks arraystack }

# callstack -- runtime
MakeRuntime â† {âŠƒ(âˆ˜|EmptyStack|{EmptyStack EmptyStack}|[])}

RtCallStack â† Â°â–¡âŠ¢
RtStack â† Â°â–¡âŠ¡1
RtTempStacks â† Â°â–¡âŠ¡2
RtArrayStack â† Â°â–¡âŠ¡3

# count runtime -- runtime'
RtTouchStack â† (|2
  - âŠ™(â§»RtStack.) # compute stacklength if count values were popped
  # -- newlength runtime
  âœâŠ™RtArrayStack â†§ # lower arraystack entries if above newlength

)

# count runtime -- values runtime'
RtPop â† (
  âŠƒ(âˆ˜|RtTouchStack)
  # -- count runtime'
  âœâŠ™RtStack âŠƒâ†™â†˜
)

# value(s) runtime -- runtime'
RtPush â† âœâŠ™RtStack âŠ‚

FrameTypePlain â† 0
FrameTypeRepeat â† 1

# frame = { frametype ({ pc addrs } | { counter count fn }) }

# slice -- frame
MakePlainFrame â† (|1
  ExpandSlice
  0 # pc
  {âŠ™âˆ˜}
  {FrameTypePlain âˆ˜}
)

# count [fnsig fnslice] -- frame
MakeRepeatFrame â† (|2
  âŠ™(âŠ¢â‡Œ) # keep only fnslice
  0     # pc
  {âŠ™âŠ™âˆ˜}
  {FrameTypeRepeat âˆ˜}
)

FrameType â† Â°â–¡âŠ¡0

ToDo â† â¤âŠ™0 $"_ is not implemented"

Trace â† âŠƒâˆ˜(&p$"â”Œâ•´â¸®\n_\nâ””â•´â•´â•´â•´"$"â”œâ•´_")

Stack â† âŠƒâˆ˜(&p$"â”Œâ•´?\n_\nâ””â•´â•´â•´â•´"/âŠ$"_\n_"â‰¡(â–¡$"â”œâ•´_"Â°â–¡)â‡Œ)

Args â† â†˜1 &args

NoadicNoOutputNames â† {"stack" "inv_stack"}
NoadicNoOutputFns â† (Stack|Stack)

NoadicOneOutputNames â† {"tag" "now" "eta" "pi" "tau" "infinity" "scan_line" "rand" "args"}
NoadicOneOutputFns â† (tag|now|Î·|Ï€|Ï„|âˆ|&sc|âš‚|Args)

MonadicNoOutputNames â† {"pop" "show" "prin" "print" "change_directory" "im_show"}
MonadicNoOutputFns â† (;|&s|&pf|&p|&cd|&ims)

Last â† (|1
  âŠ¢â‡Œ
)

MonadicOneOutputNames â† {
  "trace"
  "not" "sign" "neg" "abs" "sqrt" "sin" "floor" "ceil" "round"
  "len" "shape" "range" "first" "reverse" "deshape" "fix" "bits" "transpose" "rise" "fall"
  "where" "classify" "deduplicate" "box" "unbox" "parse"
  "utf" "type" "f_read_all_bytes" "f_read_all_str"
  "acos" "asin" "cos"
  "first_max_index" "first_min_index" "first_where"
  "inv_fix" "inv_parse" "inv_trace" "inv_utf" "inv_where"
  "inverse_bits"
  "last" "last_max_index" "last_min_index"
  "sort_down" "sort_up"}
MonadicOneOutputFns â† (
  Trace
| Â¬
| Â±
| Â¯
| âŒµ
| âˆš
| â—‹
| âŒŠ
| âŒˆ
| â…
| â§»
| â–³
| â‡¡
| âŠ¢
| â‡Œ
| â™­
| Â¤
| â‹¯
| â‰
| â
| â–
| âŠš
| âŠ›
| âŠ
| â–¡
| Â°â–¡
| â‹•
| utf
| type
| &frab
| &fras
| âˆ˜ ToDo "acos"
| âˆ˜ ToDo "asin"
| âˆ˜ ToDo "cos"
| âˆ˜ ToDo "first_max_index"
| âˆ˜ ToDo "first_min_index"
| âˆ˜ ToDo "first_where"
| âˆ˜ ToDo "inv_fix"
| âˆ˜ ToDo "inv_parse"
| âˆ˜ ToDo "inv_trace"
| âˆ˜ ToDo "inv_utf"
| Â°âŠš
| Â°â‹¯
| Last
| âˆ˜ ToDo "last_max_index"
| âˆ˜ ToDo "last_min_index"
| âˆ˜ ToDo "sort_down"
| âˆ˜ ToDo "sort_up"
)

MonadicTwoOutputNames â† {"dup" "gen" "inv_atan" "inv_complex" "inv_couple" "inv_map"}
MonadicTwoOutputFns â† (
  .
| gen
| . ToDo "inv_atan"
| . ToDo "inv_complex"
| . ToDo "inv_couple"
| . ToDo "inv_map"
)

DyadicNoOutputNames â† {"assert" "f_write_all"}
DyadicNoOutputFns â† (â¤|&fwa)

Unfirst â† (|2
  âœâŠ¢(â‹…âˆ˜)
)

DyadicOneOutputNames â† {
  "eq" "ne" "lt" "le" "gt" "ge" "add" "sub" "mul" "div" "mod" "pow" "log" "min" "max" "atan" "complex"
  "match" "couple" "join" "select" "pick" "reshape" "rerank" "take" "drop" "rotate" "windows" "keep" "find" "member" "index_of"
  "deal" "map" "has" "get" "remove" "regex"
  "unfirst" "unlast" "unreshape"}
DyadicOneOutputFns â† (
  =
| â‰ 
| <
| â‰¤
| >
| â‰¥
| +
| -
| Ã—
| Ã·
| â—¿
| â¿
| â‚™
| â†§
| â†¥
| âˆ 
| â„‚
| â‰
| âŠŸ
| âŠ‚
| âŠ
| âŠ¡
| â†¯
| â˜‡
| â†™
| â†˜
| â†»
| â—«
| â–½
| âŒ•
| âˆŠ
| âŠ—
| deal
| map
| has
| get
| remove
| regex
| Unfirst
| â‹…âˆ˜ ToDo "unlast"
| â‹…âˆ˜ ToDo "unreshape"
)

DyadicTwoOutputNames â† {"flip"}
DyadicTwoOutputFns â† (:|â¤"bad prim id"0)

DyadicThreeOutputNames â† {"over"}
DyadicThreeOutputFns â† (,|â¤"bad prim id"0 ,)

TriadicOneOutputNames â† {
  "insert"
  "undrop"
  "unkeep"
  "unpick"
  "unrerank"
  "unselect"
  "untake"}
TriadicOneOutputFns â† (
  insert
| â‹…â‹…âˆ˜ ToDo "undrop"
| â‹…â‹…âˆ˜ ToDo "unkeep"
| â‹…â‹…âˆ˜ ToDo "unpick"
| â‹…â‹…âˆ˜ ToDo "unrerank"
| â‹…â‹…âˆ˜ ToDo "unselect"
| â‹…â‹…âˆ˜ ToDo "untake"
)

# runtime -- runtime'
Identity â† (|1
  RtTouchStack 1
)

# runtime -- runtime'
Repeat â† (|1
  Â°{âŠ™âˆ˜} RtPop 2 # get fn and repeat count from stack
  # -- fn count runtime'
  âŠƒ(â‹…Â±|MakeRepeatFrame :)
  (
    # special case 0 count: do nothing (return runtime)
    â‹…âˆ˜
  | # -- newframe runtime
    âœâŠ™RtCallStack âŠ‚
  )
)

SpecialNames â† {
  "identity" "reduce" "fold" "scan" "each" "rows" "table" "cross" "repeat" "group" "partition" "unpack"
  "do" "fill" "try" "this" "recur" "bind" "memo" "spawn" "wait" "send" "recv" "tryrecv" "dump"
  "inv_dump" "inv_scan" "ungroup" "unpartition"}
SpecialFns â† (
  Identity
| ToDo "reduce"
| ToDo "fold"
| ToDo "scan"
| ToDo "each"
| ToDo "rows"
| ToDo "table"
| ToDo "cross"
| Repeat
| ToDo "group"
| ToDo "partition"
| ToDo "unpack"
| ToDo "do"
| ToDo "fill"
| ToDo "try"
| ToDo "this"
| ToDo "recur"
| ToDo "bind"
| ToDo "memo"
| ToDo "spawn"
| ToDo "wait"
| ToDo "send"
| ToDo "recv"
| ToDo "tryrecv"
| ToDo "dump"
| ToDo "inv_dump"
| ToDo "inv_scan"
| ToDo "ungroup"
| ToDo "unpartition"
)

PrimNameLists â† {
  NoadicNoOutputNames
  NoadicOneOutputNames
  MonadicNoOutputNames
  MonadicOneOutputNames
  MonadicTwoOutputNames
  DyadicNoOutputNames
  DyadicOneOutputNames
  DyadicTwoOutputNames
  DyadicThreeOutputNames
  TriadicOneOutputNames
  SpecialNames}

PrimIds â† â‰¡(â–¡â‰¡âŠ‚âŠ™Â°â–¡) âŠƒ(â‡¡â§»|â‰¡(â–¡â‡¡â§»)) PrimNameLists

PrimNamesToIds â† map âˆ©âŠ/âŠ‚ PrimNameLists PrimIds

# primid runtime -- runtime'
ExecPrimitive â† (
  Â°âŠŸ
  # -- primtype primsubid runtime
  (
    NoadicNoOutputFns
  | RtPush â–¡ NoadicOneOutputFns
  | MonadicNoOutputFns âŠ™(Â°{âˆ˜}RtPop 1)
  | RtPush â–¡ MonadicOneOutputFns âŠ™(Â°{âˆ˜}RtPop 1)
  | RtPush {âŠ™âˆ˜} MonadicTwoOutputFns âŠ™(Â°{âˆ˜}RtPop 1)
  | DyadicNoOutputFns âŠ™(Â°{âŠ™âˆ˜}RtPop 2)
  | RtPush â–¡ DyadicOneOutputFns âŠ™(Â°{âŠ™âˆ˜}RtPop 2)
  | RtPush {âŠ™âˆ˜} DyadicTwoOutputFns âŠ™(Â°{âŠ™âˆ˜}RtPop 2)
  | RtPush {âŠ™âŠ™âˆ˜} DyadicThreeOutputFns âŠ™(Â°{âŠ™âˆ˜}RtPop 2)
  | RtPush â–¡ TriadicOneOutputFns âŠ™(Â°{âŠ™âŠ™âˆ˜}RtPop 3)
  | SpecialFns
  )
)

# {ident} runtime -- runtime'
Comment â† âˆ˜ToDo "Comment"

# {index call sig} runtime -- runtime'
CallGlobal â† âˆ˜ToDo "CallGlobal"

# {span index} runtime -- runtime'
BindGlobal â† âˆ˜ToDo "BindGlobal"

# [] runtime -- runtime'
BeginArray â† (|2
  ; # drop dummy arg
  # -- runtime
  # get current stack len
  â§»RtStack.
  # push it onto arraystack
  # -- stacklen runtime
  âœâŠ™RtArrayStack âŠ‚
)

# boxed runtime -- runtime'
EndArray â† (|2
  # pop current stack contents
  # -- boxed runtime
  âŠ™(
    # -- runtime
    âœRtArrayStack (
      âŠƒ(â†˜1|Â¯Â°â–¡âŠ¢)
    )
    # -- runtime -startlevel
    âœRtStack(âŠƒâ†™â†˜ :) # take and drop from bottom of stack

  )
  # -- boxed runtime' values
  (
    # unboxed: need to unbox stack values
    âŠ™(
      Â±â§».
      (
        [] # special case for empty array

        | âŠâ‰¡âˆ˜
      )
    )
  | # boxed: nothing to do

  )
  # -- runtime' value
  RtPush â–¡:
)

# fn on stack = [ sig slice ]

# [] runtime -- runtime'
Call â† (|2
  MakePlainFrame âŠ¡1Â°{âˆ˜} RtPop 1 ;
  âœâŠ™RtCallStack âŠ‚ # push new frame onto callstack

)

# [ sig slice ] runtime -- runtime'
PushFunc â† RtPush â–¡

# {fncount sig} runtime -- runtime'
Switch â† (|2
  Â°{âŠ™âˆ˜} # get fncount, sig
  # -- fncount sig runtime
  âŠƒ(â‹…âˆ˜|RtPop +1 âŠ™â‹…âˆ˜) # pop fns and selector
  # -- sig values runtime'
  âŠ™(Â°â–¡âŠ¡ -2 Â¯Â°â–¡âŠ¢â‡Œ.) # pick selected fn # TODO: array selectors
  # -- sig fn runtime
  âŠƒ(:Â°âŠŸ â‹…âˆ˜|âŠ™â‹…âˆ˜)
  # -- fnslice fnsig sig runtime
  âŠ“(
    MakePlainFrame
  |                 # compute args to discard
    âŠƒ(â‹…âŠ¢|â‹…â‹…âˆ˜|/-â‡Œ -) # -- sig.args runtime discardcount=((sig.args - f.sig.args) - (sig.outputs - f.sig.outputs))
    âœâŠ™RtStack (
      # -- takecount stack discardcount
      âœâ†™(â†˜ Â¯:) # discard extra args

    )
    # --runtime

  )
  # -- newframe runtime
  âœâŠ™RtCallStack âŠ‚ # push new frame onto callstack

)

# parts runtime -- runtime'
Format â† (|2
  âŠƒ(-1â§»|â‹…âˆ˜|âˆ˜)
  # -- runtime placeholdercount parts
  :RtPop
  # -- runtime' values parts
  âŠ™(
    â‰¡(âœÂ°â–¡$"_") # stringify values
    # -- strings parts
    â™­â‰â¬š(â–¡"")âŠŸ: # alternate fragments and values
    # -- strings
    âŠ/âŠ‚ # join everything up

  )
  # -- runtime result
  RtPush â–¡ : # push resulting string

)

# {func} runtime -- runtime'
Dynamic â† âˆ˜ToDo "Dynamic"

# {count span} runtime -- runtime'
PushLocals â† âˆ˜ToDo "PushLocals"

# {} runtime -- runtime'
PopLocals â† âˆ˜ToDo "PopLocals"

# {index span} runtime -- runtime'
GetLocal â† âˆ˜ToDo "GetLocal"

# {count span unbox} runtime -- runtime'
Unpack â† âˆ˜ToDo "Unpack"

# {count} runtime -- runtime'
PushTempFunctions â† âˆ˜ToDo "PushTempFunctions"

# {count} runtime -- runtime'
PopTempFunctions â† âˆ˜ToDo "PopTempFunctions"

# {offset sig span} runtime -- runtime'
GetTempFunction â† âˆ˜ToDo "GetTempFunction"

TouchStack â† RtTouchStack

# [stackid count] runtime -- runtime'
PushTemp â† (|2
  Â°âŠŸ
  # -- stackid count runtime
  âŠ™(:RtPop)
  # -- stackid runtime values
  âœ(Â°â–¡âŠ¡âŠ™RtTempStacks) (âŠ‚â‡Œ:)
)

# [stackid count] runtime -- runtime'
PopTemp â† (|2
  : Â°âŠŸ
  # -- count stackid runtime
  âœ(âŠ™(Â°â–¡âŠ¡) âŠ™âŠ™RtTempStacks) âŠƒâ†™â†˜
  # -- runtime values
  RtPush â‡Œ # push to stack

)

# [stackid count] runtime -- runtime'
CopyToTemp â† (|2
  Â°âŠŸ
  # -- stackid count runtime
  # copy from stack
  âŠƒâ‹…(â†™ âŠ™RtStack) âŠ™â‹…âˆ˜
  # -- values stackid runtime
  âœâŠ™âŠ™RtTempStacks âœâŠ™(Â°â–¡âŠ¡) (âŠ‚â‡Œ)
)

# [stackid offset count] runtime -- runtime'
CopyFromTemp â† (|2
  Â°[âŠ™âŠ™âˆ˜]
  # -- stackid offset count runtime
  âŠƒ(â‹…:|Â°â–¡âŠ¡ âŠ™(RtTempStacks â‹…â‹…âˆ˜)|â‹…â‹…â‹…âˆ˜)
  # -- count offset tempstack runtime
  â†™ âŠ™â†˜
  # -- values runtime
  RtPushâ‡Œ # push to stack

)

# [stackid count] runtime -- runtime'
DropTemp â† (|2
  :Â°âŠŸ
  # -- count stackid runtime
  âœâŠ™âŠ™RtTempStacks âœâŠ™(Â°â–¡âŠ¡) â†˜
)

# {sig} runtime -- runtime'
PushSig â† âˆ˜ToDo "PushSig"

# {} runtime -- runtime'
PopSig â† âˆ˜ToDo "PopSig"

# {i n} runtime -- runtime'
SetOutputComment â† âˆ˜ToDo "SetOutputComment"

# count runtime -- runtime'
TransposeN â† (|2
  âŠ™(Â°{âˆ˜}RtPop 1)
  # -- count array runtime
  (â¥â‰|â¥Â°â‰Â¯) <0. # repeat transpose
  RtPush â–¡      # push result

)

InstrTypePush â† 0
InstrTypePrim â† 1
InstrTypeOther â† 2

InstrNames â† {
  "Comment"
  "CallGlobal"
  "BindGlobal"
  "BeginArray"
  "EndArray"
  "Call"
  "PushFunc"
  "Switch"
  "Format"
  "Dynamic"
  "PushLocals"
  "PopLocals"
  "GetLocal"
  "Unpack"
  "PushTempFunctions"
  "PopTempFunctions"
  "GetTempFunction"
  "TouchStack"
  "PushTemp"
  "PopTemp"
  "CopyToTemp"
  "CopyFromTemp"
  "DropTemp"
  "PushSig"
  "PopSig"
  "SetOutputComment"
  "transpose_n"}

InstrFns â† (
  Comment
| CallGlobal
| BindGlobal
| BeginArray
| EndArray
| Call
| PushFunc
| Switch
| Format
| Dynamic
| PushLocals
| PopLocals
| GetLocal
| Unpack
| PushTempFunctions
| PopTempFunctions
| GetTempFunction
| TouchStack
| PushTemp
| PopTemp
| CopyToTemp
| CopyFromTemp
| DropTemp
| PushSig
| PopSig
| SetOutputComment
| TransposeN
)

InstrNamesToIds â† map âŠƒ(âˆ˜|â‡¡â§») InstrNames

# instr = { (push|prim|other) (value|primid|{ instrid args }) }

NullToNaN â† (âˆ˜|NaN) â‰[].

DeserializeArray â† â†¬(
  : Â°{âŠ™âŠ™âˆ˜} # -- shape type elements
  âŠ“(
    âŠâ‰¡âˆ˜ # unbox shape

  | # unbox elements
    (
      â‰¡(NullToNaN Â°â–¡) # number array: replace nulls with NaN

    | â„‚â‰¡(âˆ©NullToNaN Â°{:} Â°â–¡) # complex array

    | â™­â‰¡Â°â–¡ # char array

    | # box array
      â‰¡(
        âœÂ°â–¡ (
          type.
          (
            NullToNaN
                | â¤"complex in JSON?"0
                | âˆ˜
                | |1 â†« # nested array literal

          )
        )
      )
    )
  )
  # -- shape elements
  Â±â§».
  (
    # scalar (used for char literals)
    âŠ¢ ;
  | # regular array: apply shape
    â†¯
  )
)

# jsoninstr -- instr
AnalyzeInstr â† (
  type.
  (
    # number literal
    {InstrTypePush NullToNaN}
  | â¤$"complex in JSON?"0
  | âˆŠ: {"BeginArray" "PopLocals"}â–¡. # match instructions disguised as string literals
    (
      {InstrTypePush âˆ˜} # nope, just a regular string literal

    | {InstrTypeOther {âŠ™[]}} get: InstrNamesToIds # yep, a no-arg instr

    )
  | typeÂ°â–¡âŠ¢.
    (
      DeserializeArray # array literal
      {InstrTypePush âˆ˜}
    | â¤$"complex in JSON?"0
    | #  [ "prim", span ]
      {InstrTypePrim âˆ˜} get: PrimNamesToIds âŠ¢
    |                     # { "Instr": [ argsâ€¦ ] }
      =3â£(typeÂ°â–¡âŠ¢Â°â–¡âŠ¢)â‹…â‹…0. # detect [ { "transpose_n": n } ]
      (
        Â°[{âŠ™âˆ˜}] MapPairs
        get: InstrNamesToIds
        âŠƒ(âŠ™âˆ˜|âˆ˜)
        (
          â‹…[] # Comment(ident)

            | âˆ˜ # CallGlobal

            | âˆ˜ # BindGlobal

            | â‹…[] # BeginArray

            | Â°â–¡âŠ¢ # EndArray(boxed, span)

            | â‹…[] # Call(span)

            | [âŠ“(;|âŠâ‰¡âˆ˜|âŠâ‰¡âˆ˜)] Â°{âŠ™âŠ™âˆ˜} # PushFunc(id, slice, sig)

            | {âŠ“(âˆ˜|âŠâ‰¡âˆ˜|;)} Â°{âŠ™âŠ™âˆ˜} # Switch(count, sig, span)

            | Â°â–¡âŠ¢ # Format(parts, span)

            | âˆ˜ # Dynamic

            | âˆ˜ # PushLocals

            | âˆ˜ # PopLocals

            | âˆ˜ # GetLocal

            | âˆ˜ # Unpack

            | âˆ˜ # PushTempFunctions

            | âˆ˜ # PopTempFunctions

            | âˆ˜ # GetTempFunction

            | Â°â–¡âŠ¢ # TouchStack(count, span)

            | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # PushTemp(stack, count, span)

            | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # PopTemp(stack, count, span)

            | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # CopyToTemp(stack, count, span)

            | [âŠ™âŠ™âˆ˜] âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™âŠ™; Â°{âŠ™âŠ™âŠ™âˆ˜} # CopyFromTemp(stack, offset, count, span)

            | âŠŸ âŠ—: {"Inline" "Under"}â–¡ âŠ™âŠ™; Â°{âŠ™âŠ™âˆ˜} # DropTemp(stack, count, span)

            | âˆ˜ # PushSig

            | âˆ˜ # PopSig

            | âˆ˜ # SetOutputComment

        )
        :
        {InstrTypeOther {âŠ™âˆ˜}}
        | # other
        Â°{âŠ™âˆ˜}âŠ¢MapPairsÂ°â–¡âŠ¢
        get: InstrNamesToIds
        {InstrTypeOther {âŠ™âˆ˜}}
      )
    )
  )
)

# runtime instr -- runtime'
ExecInstr â† (|2
  :
  # -- instr runtime
  Â°{âŠ™âˆ˜} # -- instrtype instrdetail runtime
  (
    # push
    # -- value runtime
    RtPush â–¡ # push onto stack

  | # prim
    # -- primid runtime
    ExecPrimitive
  | # other
    # -- instr runtime
    Â°{âŠ™âˆ˜} # -- instrid instrargs runtime
    InstrFns
  )
)

# { frametype { pc addrs } } -- bool
PlainFrameDone â† â‰¤ âŠ™â§» Â°{âŠ™âˆ˜} Â°â–¡âŠ¢â‡Œ

# { frametype { pc addrs } } instrs -- instr
PlainFrameGetInstr â† Â°â–¡âŠ¡âŠ¡ Â°{âŠ™âˆ˜} Â°â–¡âŠ¢â‡Œ

# { frametype { pc addrs } } -- pc
PlainFramePc â† Â°â–¡âŠ¢Â°â–¡âŠ¢â‡Œ

# { frametype { counter count fn } } -- counter
RepeatFrameCounter â† Â°â–¡âŠ¢Â°â–¡âŠ¢â‡Œ

# { frametype { counter count fn } } -- bool
RepeatFrameDone â† /â‰¤ â†™2 Â°â–¡âŠ¢â‡Œ

# { frametype { counter count fn } } -- fn
RepeatFrameFn â† Â°â–¡âŠ¡2 Â°â–¡âŠ¢â‡Œ

# runtime instrs -- runtime'
Advance â† (|2
  # -- runtime instrs
  FrameType âŠ¢RtCallStack. # switch on top frame type
  (
    # plain frame
    âœ(âŠ¢RtCallStack)(|2.2
      # -- topframe instrs
      âŠƒ(
        âœPlainFramePc (+1) # bump pc
        PlainFrameDone.    # done?
        (
          # no: keep frame

            | â‹…[] # yes: destroy frame

        )
        | PlainFrameGetInstr # fetch next instr

      )
    )
    # -- runtime' instr
    ExecInstr
    # -- runtime

  | # repeat frame

    âœ(âŠ¢RtCallStack)(|1.2
      # -- topframe
      âŠƒ(
        âœRepeatFrameCounter (+1) # bump counter
        RepeatFrameDone.         # done?
        (
          # no: keep frame

            | â‹…[] # yes: destroy frame

        )
        | RepeatFrameFn
      )
    )
    # -- runtime'  fnslice
    âŠ™(MakePlainFrame) # make frame from fn
    # -- runtime newframe
    âœRtCallStack(âŠ‚ :) # push new frame onto callstack
    # -- runtime

  )
)

# jsonasm -- finalstack
Run â† (|1
  âŠƒ(
    âŠâ‰¡â‰¡âˆ˜Â°â–¡get "top_slices"
    â–½ â‰¡(Â±âŠ¢â‡Œ).       # drop empty slices
    â‰¡MakePlainFrame # initial callstack from top_slices
    MakeRuntime     # initial runtime from callstack

  | â‰¡(AnalyzeInstr Â°â–¡)Â°â–¡get "instrs"
  )
  # -- runtime instrs
  â¢(
    |2.2 Advance âŠ™. # keep instrs

  | Â±â§» RtCallStack # until callstack is empty

  )
  # -- runtime instrs
  âŠ™;      # drop instrs
  RtStack # extract stack

)

GetProgramPath â† â£(Â°â–¡âŠ¢&args|â‹…"")
EndsWith â† â‰ âŠƒâˆ˜(â†™Â¯â†§âˆ©â§»âŠ™.)
IsImported â† Â¬/â†¥[âŠƒ(EndsWith "vm.ua"|EndsWith "vm.uasm"|=0â§»)] GetProgramPath

StackColors â† +200Ã—55â‹¯5_4_6_2_3_1

DumpColoredStack â† (
  â‰¡(&pf "\x1b[m" &sÂ°â–¡ &pf $"\x1b[38;2;_;_;_m" Â°[âŠ™âŠ™âˆ˜]) â†¯: StackColors âŠ‚:3 â§». â‡Œ
)

Main â† (
  &fras Â°â–¡ âŠ¡1 &args
  JsonParse

  Run
  DumpColoredStack
)

# *** Tests support ***

MkTemp â† (â¤âŠƒ(:Â¬âŠ™â‹…âˆ˜|â–½â‰ @\n.;) &runc "mktemp") # keep the parentheses!

# contents -- â€¦
WithTempFile â† setund(
  âŠƒâˆ˜ &fwa MkTemp
| MkTemp
  âŠƒ&fwa .
| &fde
)

CompileAndRun â† (
  âŠ‚"# Experimental!\n"
  âœWithTempFile (â‹…âŠ™; &runc {"uiua" "build" "-o" "/dev/stdout" âˆ˜})
  JsonParse
  Run
)
Aeq â† â¤âŠƒ($"\nexpected\n_\ngot\n_")â‰
Check â† Aeq âŠ™CompileAndRun

---
Replace â† âŠ/âŠ‚ â†˜1 â™­â‰¡âŠ‚ {âˆ˜}: âŠ¢â‡Œâ‰ regex âŠƒ(âŠ‚"(.*?)"|âŠ‚: âŠ™â‹…âˆ˜|â‹…âˆ˜)
â¤âŠƒâ‹…âˆ˜â‰ "azzbzz" Replace "cc" "zz" "accbcc"

Escape â† â†˜Â¯1 âŠ/âŠ‚ â†˜1â™­â‰¡âŠ‚ âŠƒ(â–¡âŠ‚@\\|âŠ•â–¡âœâ–½Â¯:\+.=, âŠ™(âŠ‚:@.))
â¤âŠƒâ‹…âˆ˜â‰ "a\\b\\\"c" Escape @" "a\\b\"c"
â¤âŠƒâ‹…âˆ˜â‰ "a\\\\b\"c" Escape @\\ "a\\b\"c"

MakeCheckProgram â† (
  âŠƒ(
    â¤"must run with absolute path for tests"=@/âŠ¢. GetProgramPath
  | âŠœâ–¡â‰ @Â§.
    âŠƒ(
      (""|âŠ/$"_\n_") Â±â§». â†˜Â¯1
    | Â°â–¡âŠ¢â‡Œ
    )
  | $"\"_\"" Replace @Â§ "\\n" Escape @" Escape @\\
  )
  $ # Experimental!
  $ Check â† &i "_" "Check"
  $ _
  $ {
  $ _
  $ }
  $ Check: _

)

# expr -- success
AutoCheck â† (|1
  MakeCheckProgram.
  # programtext expr
  âœWithTempFile (&runc {"uiua" "run" "--no-format" âˆ˜})
  # -- exitcode stdout stderr
  âŠƒ(
    â†§ âˆ©(=0) âŠ™â‹…â§» # success is exitcode=0 && empty stderr

  | â‹…âŠ‚ # join stderr to stdout

  )
  # -- success output expr
  (
    &p$"âŒ _\n_":
    0
  | # &pâ‹…$"âœ… _"
    1
  )
)

ThreadCount â† NumProcs

Parallel! â† (
  âŠ/âŠ‚ â–½â‰¡â§». â‰¡(â–¡â‰¡wait â‰¡spawn^1 â–½â‰¡(Â¬â‰â–¡0).) â¬š(â–¡0)â†¯ âŠŸ :ThreadCount Â¯1
)

RunTests â† &pâœnow(
  {
    # literals
    $ 123
    $ "hello"
    $ @x
    $ @ğŸ˜‡
    $ []
    $ [i 0 1 2]
    $ {}
    $ [[4 5 6][7 8 9]]
    $ ["x" "y"]
    $ {"x" "yz"}
    $ i
    $ NaN
    $ [NaN]
    $ {NaN}
    $ comptime(â„‚ NaN NaN)
    $ [{}]
    $ {[]}
    $ @\\t
    $ -@\\x00 @Z

    # stack operations
    $ .2
    $ ,1 2
    $ :1 2
    $ ;1 2 3

    # monadic pervasive
    $ âˆ˜ 3
    $ Â¬ 3
    $ Â± 3
    $ Â¯ 1
    $ âŒµ `1
    $ âˆš 4
    $ â—‹ 0
    $ âŒŠ 1234.56
    $ âŒˆ 1.234
    $ â… 5.678

    # dyadic pervasive
    $ =1 2
    $ â‰ 1 2
    $ <1 2
    $ â‰¤1 2
    $ >1 2
    $ â‰¥1 2
    $ +2 4
    $ -2 5
    $ *2 4
    $ Ã·2 6
    $ â—¿2 7
    $ â¿2 3
    $ â‚™2 8
    $ â†§3 8
    $ â†¥3 8
    $ âˆ 1 0
    $ â„‚1 2

    # monadic array
    $ â§»5
    $ â–³5
    $ â‡¡5
    $ âŠ¢[1 2 3]
    $ â‡Œ[1 2 3]
    $ â™­5
    $ Â¤5
    $ â‹¯27
    $ â‰.[[1 2] [3 4] [5 6]]
    $ â[6 2 7 0 Â¯1 5]
    $ â–[6 2 7 0 Â¯1 5]
    $ âŠš [1 0 0 1 0 1 1 0]
    $ âŠ›[7 7 8 0 1 2 0]
    $ âŠ[7 7 8 0 1 2 0]
    $ âŠ”â–¡5
    $ â‹• "17"

    # dyadic array
    $ â‰ [0 1 2] [0 1 2]
    $ âŠŸ 1 2
    $ âŠ‚ 1 2
    $ âŠ 2 [8 3 9 2 0]
    $ âŠ¡ 2 [8 3 9 2 0]
    $ â†¯ [2 3] [1 2 3 4 5 6]
    $ â˜‡ 0 â†¯[2 3 3]â‡¡18
    $ â†™ 3 [8 3 9 2 0]
    $ â†˜ 3 [8 3 9 2 0]
    $ â†»1 â‡¡5
    $ â—«2 .â‡¡4
    $ â–½ [1 0 2 3 1] [8 3 9 2 0]
    $ âŒ• 5 [1 8 5 2 3 5 4 5 6 7]
    $ âˆŠ 2 [1 2 3]
    $ âŠ— 2 [1 2 3]

    # misc
    $ â¤"ok" 1
    $ gen0
    $ deal0 [1 2 3 4 5]
    $ regex "h([io])" "hihaho"
    $ utf "hello!"
    $ â‰¥0 tag
    $ type 5
    $ Â±now
    $ - . âš‚

    # constants
    $ Î·
    $ Ï€
    $ Ï„
    $ âˆ

    # maps
    $ map 1\_2 3\_4
    $ insert 1 2 {}
    $ has 1 map 1\_2 3\_4
    $ get 1 1\_2 3\_4
    $ remove 3 map 1\_2 3\_4

    # System
    $ &sc
    $ &cd "/tmp"
    $ &fras "/tmp/data1.tmp" &fwa "/tmp/data1.tmp" "data"
    $ &frab "/tmp/data2.tmp" &fwa "/tmp/data2.tmp" "data"
    $ &ims [[1 0][0 1]]
    $ type &args

    # Switch
    $ (10|20)0
    $ (10 20|20 30)1
    $ (*2|*4+)1 10 90
    $ (*2|*4+)0 10 90
    $ (*2|*4+)0 10 90 99
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)0 10 20 30 40
    $ (|4.3 1 2 3 â‹…â‹…â‹…;||3.2 5 6 â‹…â‹…;)1 10 20 30 40

    # Format
    $ $"\_" 100
    $ $"[x=\_ y=\_]" 100 200

    # PushTemp, PopTemp
    $ âŠ™100 200
    $ âŠ™âŠ™âˆ˜ 100 200 300
    $ âŠ™â‹…â‹…âŠ™100 200 300 400 500
    $ âŠ™â‹…â‹…âŠ™âˆ˜ 100 200 300 400 500
    $ âŠƒ(Ã—2|+1) 100
    $ âŠƒ(Ã—2+|+1) 100 200 300
    $ âŠƒ(Ã—2|âŠ™âˆ˜) 10 100 1000

    # CopyToTemp, CopyFromTemp, DropTemp
    $ âœ(Ã—10) â… 1.234
    $ âœâŠ¢(Ã—2) [1 2 3]
    $ âŠ¢â‡Œ[1 2 3]

    # Call
    $ F â† â¤.1 Â§ F

    # BeginArray, EndArray, TouchStack
    $ {. "hello"}
    $ [. 123]
    $ [. {. 123}]
    $ [. 123 456] 789
    $ {;1} 789
    $ [;1] 789
    $ {âŠ™âˆ˜} 1 2 3
    $ [âˆ˜] 1
    $ [=] 1 2
    $ [:] 1 2
    $ [,] 1 2
    $ [insert 5 6] map [1 2] [3 4]
    $ [.] 1
    $ [$"hello \_"] 123

    # inv_where
    $ Â°âŠš[0 3 5 6]

    # inverse_bits
    $ Â°â‹¯ [1 0 1]

    # unrerank
    # $ âœ(â˜‡0)âˆ˜ [[2 3][4 5]]

    # reduce
    # $ /+ [1 2 3 4 5]
    # $ /- [1 2 3 4 5]
    # $ /- [1 2 3 4 5]
    # $ \- [1 2 3 4 5]
    # $ /(Ã—+1) [1 2 3 4 5]
    # $ /âŠ‚ .â†¯[2 2 4]â‡¡16
    # $ /+ []
    # $ /Ã— []
    # $ /â†¥ []
    # $ /â†§ []
    # $ /âˆ  []

    # fold
    # $ âˆ§+ [1 2 3] 10
    # $ âˆ§+ [] 10
    # $ âˆ§(âŠƒ+(Ã—âŠ™â‹…âˆ˜)) +1â‡¡5 0 1
    # $ âˆ§(âŠƒ+(Ã—âŠ™â‹…âˆ˜))âŠ™(0 1) +1â‡¡5
    # $ âˆ§âŠƒ(+âŠ™â‹…âˆ˜)(Ã—â‹…âŠ™â‹…âˆ˜) [1 2 3] [4 5 6] 0 1
    # $ âˆ§(âŠ‚âŠ‚) [1 2 3] 4 []
    # $ â‡Œâˆ§(âŠ‚+âŠ™(âŠ¢.)) âŠƒâ†˜â†™1 [1 2 3 4]

    # scan
    # $ \+   [1 2 3 4]
    # $ \-   [1 2 3 4]
    # $ \(-:) [1 2 3 4]
    # $ â–½\â†§â‰ @ . "Hello World!"
    # $ âŠ•â–¡\+=@    . "Everyday man's on the block"
    # $ âŠ•â–¡\+â†»Â¯1=@ . "Everyday man's on the block"

    # each
    # $ âˆµ(âŠŸ.) [1 2 3 4]
    # $ âˆµâŠ‚ [1 2 3] [4 5 6]
    # $ âˆµâŠ‚ [1 2] [[4 5] [6 7]]
    # $  + [1 2 3] [4 5 6]

    # rows
    # $  /+ [[1 2 3] [4 5 6] [7 8 9]]
    # $ â‰¡/+ [[1 2 3] [4 5 6] [7 8 9]]
    # $ â‰¡/+ [[1 2] [3 4]] [5 6]
    # $ â‰¡âŠ‚  [[1 2] [3 4]] [5 6]
    # $ â‰¡âŠ‚ [1 2 3] 4
    # $ â‰¡âŠ‚ 1 [2 3 4]
    # $ â‰¡(âŠ‚âŠ‚) 1 [2 3 4] 5
    # $ â‰¡âŠ‚ Â¤  [1 2 3] [4 5 6]
    # $ â‰¡âŠ‚ âŠ™Â¤ [1 2 3] [4 5 6]

    # table
    # $ âŠ+ [1 2 3] [4 5 6 7]
    # $ âŠâŠ‚ [1 2] [3 4]
    # $ â–³âŠ+ [1 2] [3 4 5]
    # $ â–³âŠâŠ‚ [1 2] [3 4 5]
    # $ â–³âŠ+ [[1 2 3] [4 5 6]] [7 8 9 10]
    # $ â–³âŠâŠ‚ [[1 2 3] [4 5 6]] [7 8 9 10]

    # cross
    # $ âŠ âŠ‚ ,,[[7 8] [9 10]][[1 2] [3 4] [5 6]]
    # $ âŠ (âŠ‚âŠ‚) [1 2] [3 4] [5 6]
    # $ /âŠ‚ âŠ (âŠ‚âŠ‚) âŠ™Â¤ [1 2] [3 4] [5 6]

    # repeat
    $ â¥(+2)5 99 200
    $ â¥(+2)0 99 200
    $ â¥(âŠ‚2)5 []
    $ â¥âŠ‚3 [] 1 2 3

    # transpose_n
    $ â‰â‰[1 2]
    $ Â°(â‰â‰)[1 2]

    # group
    # $ âŠ•âˆ˜ [0 2 2 1 0 1] [1 2 3 4 5 6]
    # $ âŠ•âŠ‚ [] [0 2 2 1 0 1] [1 2 3 4 5 6]
    # $ âŠ•â–¡ [0 1 0 2 1 1] [1 2 3 4 5 6]
    # $ âŠ•{âŠ¢:â§».} âŠ›.âŠâ. $ Count the characters is this string
    # $ âœâŠ•â–¡â‰¡â‡Œ â‰ @ . $ These are some words

    # partition
    # $ âŠœâˆ˜ [0 0 2 2 1 1 3 3] [1 2 3 4 5 6 7 8]
    # $ âŠœâŠ‚ [] [0 0 2 2 1 1 3 3] [1 2 3 4 5 6 7 8]
    # $ âŠœâ–¡ [0 2 3 3 3 0 1 1] [1 2 3 4 5 6 7 8]
    # $ âŠœâ–¡ â‰ @ . $ Hey there friendo
    # $ âœâŠœâ–¡â‡Œ â‰ @ . $ These are some words

    # unpack
    # $ âŠ/âŠ‚ {"a" "bc" "def"}
    # $ âŠ(Â¯â–¡3)
    # $ âŠ( â–¡3)

    # do
    # $ â¢(Ã—2)(<1000) 1
    # $ â¢âŠ‚(Â¬âˆŠ,,(+1Ã—3|Ã·2)=0â—¿2.âŠ¢.) [7]
    # $ â¢(Ã—3)(<100)  1
    # $ â¢(Ã—3)(<100.) 1
    # $ â¢(âŠƒ(Ã—2)âŠ‚)(<100) 1 []

    # fill
    # $ â¬š0â†™ 7 [8 3 9 2 1]
    # $ â¬šÏ€â†™ Â¯6 [1 2 3]
    # $ â¬š42â†™ 4 [[1 2 3] [4 5 6]]
    # $ â¬š0âŠŸ 1 [2 3]
    # $ â¬š0âŠŸ [1 2] [3 4 5 6]
    # $ â¬š0âŠŸ [1 2 3] [[4 5] [6 7]]
    # $ â¬š0âŠ‚ 1 [[2 3 4] [5 6 7]]
    # $ â¬š0âŠ‚ [[1 2] [3 4]] [5 6 7]
    # $ â¬š0[1 [2 3] [4 5 6]]
    # $ â¬š0+ [1 2 3] [10 9 8 7 6 5]
    # $ â¬š0\âŠ‚ [1 2 3 4 5]
    # $ â¬š@ âŠœâˆ˜â‰ @ . "No â–¡ needed!"
    # $ â¬šâˆâŠ [3 7 0] [8 3 9 2 0]
    # $ â¬š0â–½ â‰¡/>â—«2. [1 8 0 2 7 2 3]
    # $ â¬š0â†¯ [3 5] â‡¡9
    # $ â¬š0â†» 2 [1 2 3 4 5]
    # $ â¬šâˆ˜+ 100 [1 2 3 4] [5 6]
    # $ â¬š0(â†»1 â‡¡5 â¬š[]â†»3 â‡¡5 â†»2 â‡¡5)

    # try
    # $ â£(+1 2)$"Error:  "
    # $ â£(+@a @b)$"Error:  "

    # this
    # recur
    # $ â†¬((|1 Ã—â†«-1.|1)<2.) 5

    # bind
    # $ bind(âŠ‚ b + a c) 1 2 3

    # memo
    # $ âˆµmemo(+âŒŠÃ—10âš‚)[1 1 2 2 3 3]

    # spawn
    # wait
    # $ wait spawnâ‡¡ 10

    # send
    # recv
    # tryrecv

    # dump
    # $ dumpâŠ¢ [1 2 3] 4 [5 6 7]
  }

  âŠ/âŠ‚ â‰¡(âœÂ°â–¡(âŠœâ–¡ â‰ @\n.))
  Parallel!(AutoCheck Â°â–¡)
  &pâŠ¡:"ğŸ˜­ğŸ‰" /â†§
)
Â¬IsImported
(
  # imported: do nothing

| # running
  =1â§»&args
  (
    # do nothing

  | RunTests
  )
)
---

Â¬IsImported
(
  # imported: do nothing

| # running
  >1â§»&args
  (
    # do nothing

  | Main
  )
)
